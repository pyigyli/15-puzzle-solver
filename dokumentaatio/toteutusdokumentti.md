# Toteutusdokumentti

Ohjelmassa 15-pelin ratkaiseminen perustuu A*-algoritmiin. Kun algoritmille annetaan pelilauta, se alkaa generoida verkkoa, jossa yhden solumn jokainen naapuri on yksi mahdollinen siirto. A* toimii kuin Dijkstran algoritmi, mutta tarkastettavien solmujen lista pidetään jatkuvasti sellaisessa järjestyksessä, että seuraavaksi tarkastettava solmu on mahdollisimman lähellä ratkaistua pelilautaa. Jotta tiedetään, mikä pelilauta on parempi kuin toinen, käytetään apuna heuristiikkafunktiota. Koska 15-peli sisältää niin monta laudan permutaatiota, on tavallisella sokealla hakualgoritmilla mahdotonta ratkaista peliä luotettavasti. Heuristiikkafunktiolla varmistetaan, että ratkaisu löytyy järkevässä ajassa ja ennen muistitilan loppumista. Pelilaudasta lasketaan Manhattanetäisyys sekä lineaarikonfliktien määrä. Manhattanetäisyys lasketaan summaamalla jokaisen palan etäisyys siitä, missä se sijaitsisi ratkaistussa laudassa. Lineaarikonflikti taas tarkoittaa, että kaksi nappulaa ovat oikealla suoralla, mutta jotta ne pääsisivät haluttuihin kohtiin, niiden täytyy jollain tapaa kiertää toistensa ohi. Algoritmi pyrkii etsimään ratkaisun mahdollisimman nopeasti, eikä välitä ratkaisun siirtojen määrästä.

Aikavaatimus A*-algoritmille on O(b^d), jossa b on haarautumiskerroin ja d ratkaisun etäisyys. 15-pelissä haarautumiskerroin on keskimäärin 3 ja maalitilan etäisyys vaihtelee paljon. Algoritmi on ahne, joten en usko yhtälön b^d pätevän tämän sovelluksen tapauksessa. Kun olen kokeillut algoritmia ei-ahneena, ratkaisun löytämisessä kestää erittäin kauan, kun taas ahne algoritmi kykenee ratkaisemaan pelilaudan silmän räpäyksessä. Algoritmin avoin lista, josta otetaan uusi solmu tarkasteltavaksi yksi kerrallaan, on keko. Sen aikavaatimus on O(log n). Rajoitin keon maksimitilavuutta 2000 elementtiin. Koska emme ole kiinnostuneita pelilaudoista, jotka ovat hyvin kaukana ratkaisusta, ei ole tarpeen tallentaa liian montaa lautaa tarkasteltavaksi. Tällöin O(log n) ajassa n pysyy pienenä. Aina kun algoritmi on lisäämässä uutta solmua tarkasteltavien listaan, sen täytyy käydä läpi kaikki edelliset läpikäydyt solmut, jottei samoja lautoja käydä läpi useasti. Tämän listan aikavaatimus on O(n). Lopullinen aikavaatimus on uskoakseni noin O(b^n), kun n kasvaa yli kahden tuhannen. Mikäli avoin lista ei ikinä täyty, aikavaatimus olisi O(b^2n), mutta tällöin ratkaisun löytymiseen ei kuluisi juuri yhtään aikaa. Kuten aijemmin mainittu, ratkaisun etäisyys b vaihtelee hyvin paljon, eikä haarautumista tapahdu samalla tavoin kuin ei-ahneessa A*-algoritmissa. Tarkkaa aikatilavuutta on vaikea antaa, mutta kuten kuvasta näkee, ratkaisuajat ovat joka tapauksessa pieniä.

Kuvassa nähtävillä 10000 satunnaisen laudan ratkaisemisesta saadut tilastot.

![kuva](https://github.com/pyigyli/15-puzzle-solver/blob/master/dokumentaatio/kuvat/size_4-10000_solves.png "Testitulokset koolla 4 10000 satunnaisella pelilaudalla")

Tilavaatimukset näille kahdelle listalle ovat O(n), jossa toinen on rajoitettu maksimissaan 2000 elementtiin.

Myöhemmin sovellusta on laajennettu toimimaan myös muille n-peleille. Algoritmin toiminta on sama, vaikka laudan koko muuttuisi. Tarkoitettu lähinnä 3-, 4- ja 5- kokoisille pelilaudoille.

Mahdollinen heikkous algoritmille on, että kaksi identtistä lautaa on mahdollista lisätä avoimelle listalle. Tämä aiheuttaa hieman turhaa laskentaa, mutta toinen elementti hylätään kuitenkin tarkasteluvaiheessa. Vaihtoehtoinen tapa tämän estämiseksi olisi käydä läpi sekä suljettu että avoin lista, ennen kuin elementtejä lisätään avoimelle listalle. En osaa sanoa parantaisiko tämä edes algoritmin nopeutta ollenkaan, mutta olen ainakin varma, ettei merkittävää parannusta nähtäisi.

Lähteinä vaatimuksien selvittämiseen käytin wikipediaa ja geegksforgeeks-sivustoa.